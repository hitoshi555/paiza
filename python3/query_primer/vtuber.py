# 解答
# N , K の制約より、各イベントについての処理を O(log N) 程度でおこなう必要があることがわかると思います。
# スーパーチャットとメンバーシップの 2 つの処理が存在しますがこれらは互いに独立しているので分けて考えましょう。
# それぞれのイベントを処理するために必要な操作をまとめてみましょう。

# 【スーパーチャット】
# 金額と名前を受け取り、その人が既にスーパーチャットをしている場合はその人のスーパーチャットの合計金額に受け取った金額を加算する。
# 初めてのスーパーチャットの場合は、その人のスーパーチャット合計金額を受け取った金額で初期化する。
# 最後にスーパーチャットの金額が高い順に名前を呼ぶ
# これらの処理を言い換えると、主に次の 2 つの処理になります。
# 「名前から、その人のスーパーチャット総額を調べる」
# 「スーパーチャットの金額と名前のペアを金額が高い順に並び替える」
# 1 つ目の処理のような、決まった値から関連した値を取り出したい時には連想配列を使うと便利です。
# 連想配列の値には配列も指定することができるので、今回の問題では、キーを「名前」・値を「スーパーチャットの総額」とすれば良いです。
# 連想配列では、上の 2 つの処理と要素の追加をいずれも O(log N) でおこなうことができます。
# 2 つ目の処理をおこなうには、ペアを要素とする配列をソートしたり、名前と金額を関連づけてから金額でソートをおこなうなどすれば良いです。

# 【メンバーシップ】
# メンバーシップに加入した人の名前を、加入者一覧に追加する
# 最後に、加入者の名前を辞書順で読み上げる
# これは、加入者を配列などで管理したのち、ソートをおこなうことで処理することができます。
# 以上の 2 つの処理を入力に応じておこなうことでこの問題を解くことができます。
N = int(input())

superchat = {}
member = set()
for _ in range(N):
    event = input().split()

    name = event[0]
    verb = event[1]
    if verb == "give":
        money = int(event[2])
        if name not in superchat:
            superchat[name] = (money, name)
        else:
            superchat[name] = (superchat[name][0] + money, name)
    else:
        member.add(name)

for name, money in sorted(superchat.items(), key=lambda x: x[1], reverse=True):
    print(name)
for name in sorted(member):
    print(name)